sys模块：
sys.argv           命令行参数List，第一个元素是程序本身路径 
sys.modules.keys() 返回所有已经导入的模块列表 
sys.exc_info()     获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息 
sys.exit(n)        退出程序，正常退出时exit(0) 
sys.hexversion     获取Python解释程序的版本值，16进制格式如：0x020403F0 
sys.version        获取Python解释程序的版本信息 
sys.maxint         最大的Int值 
sys.maxunicode     最大的Unicode值 
sys.modules        返回系统导入的模块字段，key是模块名，value是模块 
sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 
sys.platform       返回操作系统平台名称 
sys.stdout         标准输出
sys.stdin          标准输入
sys.stderr         错误输出
sys.exc_clear()    用来清除当前线程所出现的当前的或最近的错误信息
sys.exec_prefix    返回平台独立的python文件安装的位置
sys.byteorder      本地字节规则的指示器，big-endian平台的值是'big',little-endian平台的值是'little'
sys.copyright      记录python版权相关的东西
sys.api_version    解释器的C的API版本
sys.version_info 
>>> sys.version_info
(2, 4, 3, 'final', 0) 'final'表示最终,也有'candidate'表示候选，表示版本级别，是否有后继的发行
sys.displayhook(value)      如果value非空，这个函数会把他输出到sys.stdout，并且将他保存进__builtin__._.指在python的交互式解释器里，'_'代表上次你输入得到的结果，hook是钩子的意思，将上次的结果钩过来
sys.getdefaultencoding()    返回当前你所用的默认的字符编码格式
sys.getfilesystemencoding() 返回将Unicode文件名转换成系统文件名的编码的名字
sys.setdefaultencoding(name)用来设置当前默认的字符编码，如果name和任何一个可用的编码都不匹配，抛出LookupError，这个函数只会被site模块的sitecustomize使用，一旦别site模块使用了，他会从sys模块移除
sys.builtin_module_names    Python解释器导入的模块列表 
sys.executable              Python解释程序路径 
sys.getwindowsversion()     获取Windows的版本 
sys.stdin.readline()        从标准输入读一行，sys.stdout.write("a") 屏幕输出a

sys.argv
命令行参数将存储在变量sys.argv中。sys.argv列表中的第一项总是一个字符串，它包含程序的文件名或完整路径（取决于操作系统），第二项应该是第一个
命令行参数。
「argv」是「argument variable」参数变量的简写形式，一般在命令行调用的时候由系统传递给程序。这个变量其实是一个List列表，argv[0] 一般是被调用的
脚本文件名或全路径，和操作系统有关，argv[1]和以后就是传入的数据了。然后我们再看调用脚本的命令行：python using_sys.py we are argumentspython就
不用说了，「using_sys.py」脚本名，后面的用空格分割开的「we」「are」「argument」就是参数了。PS：一般参数由空格分隔，如果参数内部有空格要使用英文
双引号引起来比如这样：python using_sys.py hi "I'm 7sDream"按照教程的命令行运行脚本的时候，按照argv的定义：argv = ["using_sys.py", "we", 
"are", "argument"]然后用for对argv这个List进行迭代输出，就得到了教程里的结果。「话说你真的跟着教程做了吗？we are argument因该是你亲手输入终端的啊

mysql：
数据库表中检索多个时间（非连续的时间段）
select * from table_name where date_format(date,'%Y-%m-%d') in ('2018-11-01','2018-10-31');

shelve模块用法：
shelve模块提供数据存储功能，类似于字典，都是以键值对的形式保存数据，不过在shelve模块中，key必须为字符串，而值可以是python所支持的类型。
我们可以获取一个shelve对象
sh = shelve.open('xxx')
 删除shelve对象中的某个键值对
 del sh['d']
 关闭shelve对象:
    sh.close()
  遍历所有数据
    for item in sh.items():
    
 在Python中Shelve模块提供了基本的存储操作，Shelve中的open函数在调用的时候返回一个shelf对象，通过该对象可以存储内容，即像操作字典一样进行
 存储操作。当在该对象中查找元素时，对象会根据已经存储的版本进行重新构建，当给某个键赋值的时候，元素会被存储。如下：

>>> import shelve
>>> data=shelve.open('db.dat')
>>> data['x']=['1','2','3']
>>> data['x']
['1', '2', '3']
>>> data['x'].append('4')
>>> data['x']
['1', '2', '3']
>>> 
open函数打开了db.dat文件，在键值’x’下存储了1,2,3元素，但是，上面的例子并没有将4存储在x中，原因在于4是添加到shelve对象的副本中，修改后的版本
没有被最终保存。解决的办法：在使用shelve模块修改存储对象，将临时变量绑定到获得副本上，并且在修改后重新存储该副本。
>>> import shelve
>>> data=shelve.open('db.dat')
>>> data['x']=['1','2','3']
>>> data['x']
['1', '2', '3']
>>> temp=data['x']
>>> temp.append('4')
>>> data['x']=temp
>>> data['x']
['1', '2', '3', '4']
>>> data['y']=['5','6']
>>> temp=data['y']
>>> temp.append('7')
>>> data['y']=temp
>>> data['x']
['1', '2', '3', '4']
>>> data['y']
['5', '6', '7']
>>> 
或者将open函数的writeback参数设置为true：
>>> xx=shelve.open('test.txt',writeback=True)
>>> xx['x']=['1','2','3']
>>> xx['x']
['1', '2', '3']
>>> xx['x'].append('4')
>>> xx['x']
['1', '2', '3', '4']
>>> 

案例：通过shelve构造一个“数据库”，存储姓名、年龄、电话号码等信息，代码如下：

# _*_ coding:utf-8 _*_
import sys
import shelve

def store_information(database):
    ID=input('Enter the ID number:')
    info={}
    info['name']=input('Enter the name:')
    info['age']=input('Enter the age:')
    info['phone']=input('Enter the phone:')
    database[ID]=info

def lookup_information(database):
    ID=input('Enter the ID:')
    field=input('What would you like to know?(name,age,phone)')
    field=field.strip().lower()
    print(database[ID][field])

def print_help():
    print('Please enter the help command:')
    print('store  :store informatinon to database')
    print('lookup :look up information by numID')
    print('quit   :save information and quit')
    print('?      :print help command')

def enter_command():
    cmd=input('Enter command (? for help)')
    cmd=cmd.strip().lower()
    return cmd

def main():
    database=shelve.open('db.dat')
    try:
        while True:
            cmd=enter_command()
            if cmd == 'store':
                store_information(database)
            elif cmd == 'lookup':
                lookup_information(database)
            elif cmd == '?':
                print_help()
            elif cmd == 'quit':
                return
    finally:
        database.close()  

if __name__=='__main__':main
 
 
 
 
 
 
 
 
 
 
 
