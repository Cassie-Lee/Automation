在交互式环境中输入表达式

启动IDLE就运行了交互式环境，这是和python一起安装的。在windows上，打开“开始”菜单，选择“All Program -- python3.3”，然后选择“IDLE(python GUI)”。
一个窗口会出现，包含>>>提示符，这就是交互式环境。之后就可以执行python操作。


字符串操作，例如  'string'*5

在用于两个整型或浮点型值时，*操作符表示乘法，但*操作符用于一个字符串和一个整型值时，它变成了“字符串复制”操作符。
以上表达式求值为一个字符串，它将原来的字符串重复若干次，即5次。
字符串复制是一个有用的技巧，但不像字符串连接那样常用。

注：只能用+操作符加两个整数，或连接两个字符串；不能让一个整数和一个字符串相加，因为这不符合python的语法，可以使用字符串版本的整数，修复这个错误。


用sys.exit()提前结束程序

因为这个函数在sys模块中，所以必须先导入sys。当程序执行到指令的底部时，总是会终止。但是，可以通过调用sys.exit()函数，可以让程序终止或退出。
可以在python文件中设置一个需要用户输入的节点，输入相关指令之后，就触发结束程序指令。

import sys
while True:
print('Type exit to exit.')
response = input()
if response == 'exit':
sys.exit()
print('You typed ' + response + '.')

如果程序陷入无限循环中，可以按ctrl+c终止循环。

None值:None表示没有值。
在幕后，对于所有没有return语句的函数定义，python都会在末尾加上return None。这类似于while或for循环隐式地以continue语句结尾。而且，如果使用
不带值的return语句，也就是只有return关键字本身，那么就返回None。

局部和全局作用域

在被调用函数内赋值的变元和变量，处于该函数的“局部作用域”。在所有函数之外赋值的变量，属于“全局作用域”，处于局部作用域的变量，被称为“局部
变量”。处于全局作用域的变量，被称为“全局变量”。一个变量必是其中一种，不能既是局部的又是全局的。
可以将“作用域”看成是变量的容器。当作用域被销毁时，所有保存在该作用域内的变量的值就被丢弃了。只有一个全局作用域，它是在程序开始时创建的。如
果程序终止，全局作用域就被销毁，它的所有变量就被丢弃了。否则，下次你运行程序的时候，这些变量就会记住它们上次运行时的值。
一个函数被调用时，就创建了一个局部作用域。在这个函数内赋值的所有变量，存在于该局部作用域内。该函数返回时，这个局部作用域就被销毁了，
这些变量就丢失了。下次调用这个函数，局部变量不会记得该函数上次被调用时它们保存的值。
虽然在小程序中使用全局变量没有太大问题，但当程序变得越来越大时，依赖全局变量就是一个坏习惯。

作用域很重要，理由如下：
 全局作用域中的代码不能使用任何局部变量；
 但是，局部作用域可以访问全局变量；
 一个函数的局部作用域中的代码，不能使用其他局部作用域中的变量。
 如果在不同的作用域中，你可以用相同的名字命名不同的变量。也就是说，可
以有一个名为spam 的局部变量，和一个名为spam 的全局变量。

操作符 操作 例子 求值为
** 指数 2 ** 3 8
% 取模/取余数 22 % 8 6
// 整除/商数取整 22 // 8 2
/ 除法 22 / 8 2.75
* 乘法 3 * 5 15
- 减法 5 - 2 3
+ 加法 2 + 2 4

列表连接和列表复制

+操作符可以连接两个列表，得到一个新列表，就像它将两个字符串合并成一个新字符串一样，*操作符可以用于一个列表和一个整数，实现列表的复制，
最终形成一个复制元素若干次的新列表。

利用in 和not in 操作符，可以确定一个值否在列表中。像其他操作符一样，in和not in 用在表达式中，连接两个值：一个要在列表中查找的值，以及待查找
的列表。这些表达式将求值为布尔值。

随机函数：
import random
secretNumber = random.randint(1, 20)

% 求余：最常见的应用，判断奇偶数：如果number % 2 == 0，整数number 就是偶数，如果number % 2 == 1，它就是奇数。

多重赋值技巧

多重赋值技巧是一种快捷方式，让你在一行代码中，用列表中的值为多个变量赋值，如：x,y,z=list，变量的数目和列表的长度必须严格相等。

增强的赋值语句 等价的赋值语句
spam += 1 spam = spam + 1
spam -= 1 spam = spam - 1
spam *= 1 spam = spam * 1
spam /= 1 spam = spam / 1
spam %= 1 spam = spam % 1


方法：方法和函数是一回事，只是它是调用在一个值上。如：value.way()

用index()方法在列表中查找值
列表值有一个index()方法，可以传入一个值，如果该值存在于列表中，就返回它的下标，如果该值不在列表中，python就会报valueerror，
如果列表中存在重复的值，就返回它第一次出现的下标。
list.index('xx')

列表排序
关于sort()方法，你应该注意3 件事。首先，sort()方法当场对列表排序。不要写出spam = spam.sort()这样的代码，试图记录返回值。
其次，不能对既有数字又有字符串值的列表排序，因为Python 不知道如何比较它们。
对列表调用方法sort()时，大写字母都会排在小写字母前面，如果需要忽略大小写，让列表按照普通字典顺序来排序，就在调用sort()方法时，
将关键字参数key设置为str.lower。list.sort(key=str.lower)

类似列表的类型：字符串和元组
列表并不是唯一表示序列值的数据类型。例如，字符串和列表实际上很相似，只要你认为字符串是单个文本字符的列表。对列表的许多操作，也可以作用于字符
串：按下标取值、切片、用于for 循环、用于len()，以及用于in 和not in 操作符。

元组是用圆括号（），但元组与列表的主要区别还在于，元组像字符串一样，是不可变的。元组不能让它们的值被修改、添加或删除。
如果元组中只有一个值，你可以在括号内该值的后面跟上一个逗号，表明这种情况。否则，Python 将认为，你只是在一个普通括号内输入了一个值。逗号告诉
Python，这是一个元组。

用list()和tuple()函数来转换类型
正如str(42)将返回'42'，即整数42 的字符串表示形式，函数list()和tuple()将返回传递给它们的值的列表和元组版本。
>>> tuple(['cat', 'dog', 5])
('cat', 'dog', 5)
>>> list(('cat', 'dog', 5))
['cat', 'dog', 5]
>>> list('hello')
['h', 'e', 'l', 'l', 'o']
如果需要元组值的一个可变版本，将元组转换成列表就很方便。

split函数将字符串拆分成列表:string.split(分隔符)
join将列表元素组合成字符串：'分隔符'.join(list)
str = "Line1-abcdef \nLine2-abc \nLine4-abcd";
print str.split( );
print str.split(' ', 1 );
以上实例输出结果如下：
['Line1-abcdef', 'Line2-abc', 'Line4-abcd']
['Line1-abcdef', '\nLine2-abc \nLine4-abcd']

copy 模块的copy()和deepcopy()函数

在处理列表和字典时，尽管传递引用常常是最方便的方法，但如果函数修改了传入的列表或字典，你可能不希望这些变动影响原来的列表或字典。要做到这一点，
Python 提供了名为copy 的模块，其中包含copy()和deepcopy()函数。第一个函数copy.copy()，可以用来复制列表或字典这样的可变值，而不只是复制引用。
>>> import copy
>>> spam = ['A', 'B', 'C', 'D']
>>> cheese = copy.copy(spam)
>>> cheese[1] = 42
>>> spam
['A', 'B', 'C', 'D']
>>> cheese
['A', 42, 'C', 'D']
如果要复制的列表中包含了列表，那就使用copy.deepcopy()函数来代替。deepcopy()函数将同时复制它们内部的列表。


字典与列表

不像列表，字典中的表项是不排序的。在列表中，有第一个选项的概念，但字典中没有“第一个”表项。虽然确定两个列表是否相同时，表项的顺序很重要，
但在字典中，键值对输入的顺序并不重要。
>>> spam = ['cats', 'dogs', 'moose']
>>> bacon = ['dogs', 'moose', 'cats']
>>> spam == bacon
False
>>> eggs = {'name': 'Zophie', 'species': 'cat', 'age': '8'}
>>> ham = {'species': 'cat', 'age': '8', 'name': 'Zophie'}
>>> eggs == ham
True
因为字典是不排序的，所以不能像列表那样切片。

利用keys()、values()和items()方法，循环分别可以迭代键、值或键-值对。请注意，items()方法返回的dict_items 值中，包含的是键和值的元组。

get()方法

在访问一个键的值之前，检查该键是否存在于字典中，这很麻烦。好在，字典有一个get()方法，它有两个参数：要取得其值的键，以及如果该键不存在时，
返回的备用值：
>>> picnicItems = {'apples': 5, 'cups': 2}
>>> 'I am bringing ' + str(picnicItems.get('cups', 0)) + ' cups.'
'I am bringing 2 cups.'
>>> 'I am bringing ' + str(picnicItems.get('eggs', 0)) + ' eggs.'
'I am bringing 0 eggs.'
因为picnicItems 字典中没有'egg'键，get()方法返回的默认值是0。不使用get()，代码就会产生一个错误消息。

转义字符：
“转义字符”让你输入一些字符，它们用其他方式是不可能放在字符串里的。转义字符包含一个倒斜杠（\），紧跟着是想要添加到字符串中的字符。
（尽管它包含两个字符，但大家公认它是一个转义字符。）例如，单引号的转义字符是\’。你可以在单引号开始和结束的字符串中使用它。
转义字符 打印为
\' 单引号
\" 双引号
\t 制表符
\n 换行符
\\ 倒斜杠


setdefault()方法

你常常需要为字典中某个键设置一个默认值，当该键没有任何值时使用它。代码看起来像这样：
spam = {'name': 'Pooka', 'age': 5}
if 'color' not in spam:
spam['color'] = 'black'
setdefault()方法提供了一种方式，在一行中完成这件事。传递给该方法的第一个参数，是要检查的键。第二个参数，是如果该键不存在时要设置的值。
如果该键确实存在，方法就会返回键的值。
>>> spam = {'name': 'Pooka', 'age': 5}
>>> spam.setdefault('color', 'black')
'black'
>>> spam
{'color': 'black', 'age': 5, 'name': 'Pooka'}
>>> spam.setdefault('color', 'white')
'black'
>>> spam
{'color': 'black', 'age': 5, 'name': 'Pooka'}
第一次调用setdefault()时，spam 变量中的字典变为{'color': 'black', 'age': 5, 'name':'Pooka'}。该方法返回值'black'，
因为现在该值被赋给键'color'。当spam.setdefault('color','white')接下来被调用时，该键的值“没有”被改变成'white'，
因为spam 变量已经有名为'color'的键。

漂亮打印

如果在程序中导入pprint模块，就可以使用pprint()和pformat()函数，它们将“漂亮打印”一个字典的字。如果想要字典中表项的显示
比print()的输出结果更干净，这就有用了。漂亮打印的输出看起来更干净，键排过序。
如果字典本身包含嵌套的列表或字典，pprint.pprint()函数就特别有用。
如果希望得到漂亮打印的文本作为字符串，而不是显示在屏幕上，那就调用pprint.pformat()
下面两行代码是等价的：
pprint.pprint(someDictionaryValue)
print(pprint.pformat(someDictionaryValue))

原始字符串

可以在字符串开始的引号之前加上r，使它成为原始字符串。“原始字符串”完全忽略所有的转义字符，打印出字符串中所有的倒斜杠：
>>> print(r'That is Carol\'s cat.')
That is Carol\'s cat.

用三重引号的多行字符串：
虽然可以用\n转义字符将换行放入一个字符串，但使用多行字符串通常更容易。在Python 中，多行字符串的起止是3 个单引号或3 个双引号。“三重引号”之间的
所有引号、制表符或换行，都被认为是字符串的一部分。Python 的代码块缩进规则不适用于多行字符串。

字符串下标和切片：字符串像列表一样，使用下标和切片。可以将字符串'Hello world!'看成是一个列表，字符串中的每个字符都是一个表项，有对应的下标。


字符串方法upper()、lower()、isupper()和islower()

upper()和lower()字符串方法返回一个新字符串，其中原字符串的所有字母都被相应地转换为大写或小写。字符串中非字母字符保持不变。
请注意，这些方法没有改变字符串本身，而是返回一个新字符串。如果你希望改变原来的字符串，就必须在该字符串上调用upper()或lower()，
然后将这个新字符串赋给保存原来字符串的变量。这就是为什么必须使用 spam = spam.upper()，才能改变spam 中的字符串，而不是仅仅使用spam.upper()

如果字符串至少有一个字母，并且所有字母都是大写或小写，isupper()和islower()方法就会相应地返回布尔值True。否则，该方法返回False。

isX 字符串方法

除了islower()和isupper()，还有几个字符串方法，它们的名字以is 开始。这些方法返回一个布尔值，描述了字符串的特点。下面是一些常用的isX 字符串方法：
 isalpha()返回True，如果字符串只包含字母，并且非空；
 isalnum()返回True，如果字符串只包含字母和数字，并且非空；
 isdecimal()返回True，如果字符串只包含数字字符，并且非空；
 isspace()返回True，如果字符串只包含空格、制表符和换行，并且非空；
  istitle()返回True，如果字符串仅包含以大写字母开头、后面都是小写字母的单词。


字符串方法startswith()和endswith()

startswith()和endswith()方法返回True，如果它们所调用的字符串以该方法传入的字符串开始或结束。否则，方法返回False
如果只需要检查字符串的开始或结束部分是否等于另一个字符串，而不是整个字符串，这些方法就可以替代等于操作符==，这很有用。


字符串方法join()和split()

如果有一个字符串列表，需要将它们连接起来，成为一个单独的字符串，join（）方法就很有用。join()在一个字符串上调用，参数是一个字符串列表，
返回一个字符串。返回的字符串由传入的列表中每个字符串连接而成。
>>> ', '.join(['cats', 'rats', 'bats'])
'cats, rats, bats'
>>> ' '.join(['My', 'name', 'is', 'Simon'])
'My name is Simon'
>>> 'ABC'.join(['My', 'name', 'is', 'Simon'])
'MyABCnameABCisABCSimon'
请注意，调用join()方法的字符串，被插入到列表参数中每个字符串的中间。例如，如果在', '字符串上调用join(['cats', 'rats', 'bats'])，
返回的字符串就是'cats, rats, bats'。要记住，join()方法是针对一个字符串而调用的，并且传入一个列表值（很容易不小心用其他的方式调用它）。

split()方法做的事情正好相反：它针对一个字符串调用，返回一个字符串列表。
>>> 'My name is Simon'.split()
['My', 'name', 'is', 'Simon']
默认情况下，字符串'My name is Simon'按照各种空白字符分割，诸如空格、制表符或换行符。这些空白字符不包含在返回列表的字符串中。
也可以向split()方法传入一个分割字符串，指定它按照不同的字符串分割。
>>> 'MyABCnameABCisABCSimon'.split('ABC')
['My', 'name', 'is', 'Simon']
>>> 'My name is Simon'.split('m')
['My na', 'e is Si', 'on']
一个常见的split()用法，是按照换行符分割多行字符串。
>>> spam = '''Dear Alice,
How have you been? I am fine.
There is a container in the fridge
that is labeled "Milk Experiment".

Please do not drink it.
Sincerely,
Bob'''
>>> spam.split('\n')
['Dear Alice,', 'How have you been? I am fine.', 'There is a container in the
fridge', 'that is labeled "Milk Experiment".', '', 'Please do not drink it.',
'Sincerely,', 'Bob']
向split()方法传入参数’\n’，我们按照换行符分割变量中存储的多行字符串，返回列表中的每个表项，对应于字符串中的一行。

用rjust()、ljust()和center()方法对齐文本

rjust()和ljust()字符串方法返回调用它们的字符串的填充版本，通过插入空格来对齐文本。这两个方法的第一个参数是一个整数长度，用于对齐字符串。
>>> 'Hello'.rjust(10)
'    Hello'
>>> 'Hello'.rjust(20)
'            Hello'
>>> 'Hello World'.rjust(20)
'      Hello World'
>>> 'Hello'.ljust(10)
'Hello   '
'Hello'.rjust(10)是说我们希望右对齐，将'Hello'放在一个长度为10 的字符串中。'Hello'有5 个字符，所以左边会加上5 个空格，
得到一个10 个字符的字符串，实现'Hello'右对齐。
rjust()和ljust()方法的第二个可选参数将指定一个填充字符，取代空格字符。
>>> 'Hello'.rjust(20, '*')
'***************Hello'
>>> 'Hello'.ljust(20, '-')
'Hello---------------'
center()字符串方法与ljust()与rjust()类似，但它让文本居中，而不是左对齐或右对齐。
>>> 'Hello'.center(20)
' Hello '
>>> 'Hello'.center(20, '=')
'=======Hello========'

用pyperclip 模块拷贝粘贴字符串

pyperclip 模块有copy()和paste()函数，可以向计算机的剪贴板发送文本，或从它接收文本。将程序的输出发送到剪贴板，使它很容易粘贴到邮件、
文字处理程序或其他软件中pyperclip 模块不是Python 自带的，需要安装。
>>> import pyperclip
>>> pyperclip.copy('Hello world!')
>>> pyperclip.paste()
'Hello world!'
当然，如果你的程序之外的某个程序改变了剪贴板的内容，paste()函数就会返回它。


模式匹配和正则表达式

正则表达式，简称为regex，是文本模式的描述方法》
\d是一个正则表达式，表示一位数字字符，即任何一位0到9的数字。
python使用正则表达式\d\d\d-\d\d\d-\d\d\d\d，来匹配一个十位数号码的文本：3个数字、一个短横线、3个数字、一个短横线、4个数字。
所有其他字符串都不能匹配这个正则表达式。
但正则表达式可以复杂得多。例如，在一个模式后加上花括号包围的3（{3}），就是说，“匹配这个模式3 次”。
所以较短的正则表达式\d{3}-\d{3}-\d{4}，也匹配正确的电话号码格式

创建正则表达式对象

python中所有正则表达式的函数都在re模块中，在使用相关函数时，应先导入该模块：import re
向re.compile()传入一个字符串值，表示正则表达式，它将返回一个Regex模式对象。要创建一个regex对象来匹配电话号码模式，就在交互式环境中输入以下代码：
>>>phoneNumRegex=re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')

匹配regex对象

Regex 对象的search()方法查找传入的字符串，寻找该正则表达式的所有匹配。如果字符串中没有找到该正则表达式模式，search()方法将返回None。
如果找到了该模式，search()方法将返回一个Match 对象。Match 对象有一个group()方法，它返回被查找字符串中实际匹配的文本。
>>> phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
>>> mo = phoneNumRegex.search('My number is 415-555-4242.')
>>> print('Phone number found: ' + mo.group())
Phone number found: 415-555-4242
变量名mo 是一个通用的名称，用于Match 对象。
这里，我们将期待的模式传递给re.compile()，并将得到的Regex 对象保存在phoneNumRegex 中。然后我们在phoneNumRegex 上调用search()，
向它传入想查找的字符串。查找的结果保存在变量mo 中。在这个例子里，我们知道模式会在这个字符串中找到，所以我们知道会返回一个Match 对象。
知道mo 包含一个Match 对象，而不是空值None，我们就可以在mo 变量上调用group()，返回匹配的结果。将mo.group()写在打印语句中，
显示出完整的匹配，即415-555-4242。

向re.compile()传递原始字符串

字符串'\n'表示一个换行字符，
而不是倒斜杠加上一个小写的n。你需要输入转义字符\\，才能打印出一个倒斜杠。所以'\\n'表示一个倒斜杠加上一个小写的n。但是，通过在字符串的
第一个引号之前加上r，可以将该字符串标记为原始字符串，它不包括转义字符。
因为正则表达式常常使用倒斜杠，向re.compile()函数传入原始字符串就很方便， 而不是输入额外得到斜杠。输入r'\d\d\d-\d\d\d-\d\d\d\d' ， 
比输入'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d'要容易得多。

虽然在Python 中使用正则表达式有几个步骤，但每一步都相当简单。
1．用import re 导入正则表达式模块。
2．用re.compile()函数创建一个Regex 对象（记得使用原始字符串）。
3．向Regex 对象的search()方法传入想查找的字符串。它返回一个Match 对象。
4．调用Match 对象的group()方法，返回实际匹配文本的字符串。

https://www.regexpal.com/   测试正则表达式

利用括号分组

假定想要将区号从电话号码中分离。添加括号将在正则表达式中创建“分组”：(\d\d\d)-(\d\d\d-\d\d\d\d)。然后可以使用group()匹配对象方法，
从一个分组中获取匹配的文本。
正则表达式字符串中的第一对括号是第1 组。第二对括号是第2 组。向group()匹配对象方法传入整数1 或2，就可以取得匹配文本的不同部分。
向group()方法传入0 或不传入参数，将返回整个匹配的文本
>>> phoneNumRegex = re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d\d)')
>>> mo = phoneNumRegex.search('My number is 415-555-4242.')
>>> mo.group(1)
'415'
>>> mo.group(2)
'555-4242'
>>> mo.group(0)
'415-555-4242'
>>> mo.group()
'415-555-4242'
如果想要一次就获取所有的分组，请使用groups()方法，注意函数名的复数形式。
>>> mo.groups()
('415', '555-4242')
>>> areaCode, mainNumber = mo.groups()
>>> print(areaCode)
415
>>> print(mainNumber)
555-4242
因为groups()方法返回多个值的元组，所以可以使用多重赋值的技巧。

括号在正则表达式中有特殊的含义，但是如果你需要在文本中匹配括号，怎么办？例如，你要匹配的电话号码，可能将区号放在一对括号中。在这种情况下，就
需要用倒斜杠对(和)进行字符转义：
>>> phoneNumRegex = re.compile(r'(\(\d\d\d\)) (\d\d\d-\d\d\d\d)')
>>> mo = phoneNumRegex.search('My phone number is (415) 555-4242.')
>>> mo.group(1)
'(415)'
>>> mo.group(2)
'555-4242'
传递给re.compile()的原始字符串中，\(和\)转义字符将匹配实际的括号字符。

用管道匹配多个分组

字符|称为“管道”。希望匹配许多表达式中的一个时，就可以使用它。例如，正则表达式r'Batman|Tina Fey'将匹配'Batman'或'Tina Fey'。
如果Batman 和Tina Fey 都出现在被查找的字符串中，第一次出现的匹配文本，将作为Match 对象返回。
利用findall()方法，可以找到“所有”匹配的地方。
也可以使用管道来匹配多个模式中的一个，作为正则表达式的一部分。例如，假设你希望匹配'Batman'、'Batmobile'、'Batcopter'和'Batbat'中任意一个。
因为所有这些字符串都以Bat 开始，所以如果能够只指定一次前缀，就很方便。这可以通过括号实现。
>>> batRegex = re.compile(r'Bat(man|mobile|copter|bat)')
>>> mo = batRegex.search('Batmobile lost a wheel')
>>> mo.group()
'Batmobile'
>>> mo.group(1)
'mobile'
方法调用mo.group()返回了完全匹配的文本'Batmobile'，而mo.group(1)只是返回第一个括号分组内匹配的文本'mobile'。通过使用管道字符和分组括号，
可以指定几种可选的模式，让正则表达式去匹配。
如果需要匹配真正的管道字符，就用倒斜杠转义，即\|

用问号实现可选匹配

有时候，想匹配的模式是可选的，就是说，不论这段文本在不在，正则表达式都会认为匹配。字符？表明它前面的分组在这个模式中是可选的。
>>> batRegex = re.compile(r'Bat(wo)?man')
>>> mo1 = batRegex.search('The Adventures of Batman')
>>> mo1.group()
'Batman'
>>> mo2 = batRegex.search('The Adventures of Batwoman')
>>> mo2.group()
'Batwoman'
正则表达式中的(wo)?部分表明，模式wo 是可选的分组。该正则表达式匹配的文本中，wo 将出现零次或一次。
这就是为什么正则表达式既匹配'Batwoman'，又匹配'Batman'。
你可以认为?是在说，“匹配这个问号之前的分组零次或一次”。如果需要匹配真正的问号字符，就使用转义字符\?

用星号匹配零次或多次

*（称为星号）意味着“匹配零次或多次”，即星号之前的分组，可以在文本中出现任意次。它可以完全不存在，或一次又一次地重复。
>>> batRegex = re.compile(r'Bat(wo)*man')
>>> mo1 = batRegex.search('The Adventures of Batman')
>>> mo1.group()
'Batman'
>>> mo2 = batRegex.search('The Adventures of Batwoman')
>>> mo2.group()
'Batwoman'
>>> mo3 = batRegex.search('The Adventures of Batwowowowoman')
>>> mo3.group()
'Batwowowowoman'
对于'Batman'，正则表达式的(wo)*部分匹配wo 的零个实例。对于'Batwoman'，(wo)*匹配wo 的一个实例。对于'Batwowowowoman'，(wo)*匹配wo 的4 个实例。
如果需要匹配真正的星号字符，就在正则表达式的星号字符前加上倒斜杠，即\*

用加号匹配一次或多次

*意味着“匹配零次或多次”，+（加号）则意味着“匹配一次或多次”。
星号不要求分组出现在匹配的字符串中，但加号不同，加号前面的分组必须“至少出现一次”。这不是可选的
>>> batRegex = re.compile(r'Bat(wo)+man')
>>> mo1 = batRegex.search('The Adventures of Batwoman')
>>> mo1.group()
'Batwoman'
>>> mo2 = batRegex.search('The Adventures of Batwowowowoman')
>>> mo2.group()
'Batwowowowoman'
>>> mo3 = batRegex.search('The Adventures of Batman')
>>> mo3 == None
True
正则表达式Bat(wo)+man 不会匹配字符串'The Adventures of Batman'，因为加号要求wo 至少出现一次。
如果需要匹配真正的加号字符，在加号前面加上倒斜杠实现转义：\+

用花括号匹配特定次数

如果想要分组重复特定次数，就在正则表达式中该分组的后面，跟上花括号包围的数字。例如，正则表达式(Ha){3}将匹配字符串'HaHaHa'，但不会匹配'HaHa'，
因为后者只重复了(Ha)分组两次。
除了一个数字，还可以指定一个范围，即在花括号中写下一个最小值、一个逗号和一个最大值。例如，正则表达式(Ha){3,5}将匹配'HaHaHa'、
'HaHaHaHa'和'HaHaHaHaHa'。
也可以不写花括号中的第一个或第二个数字，不限定最小值或最大值，例如，(Ha){3,}将匹配3 次或更多次实例，(Ha){,5}将匹配0 到5 次实例。花括号让正则表
达式更简短。
这两个正则表达式匹配同样的模式：
(Ha){3}
(Ha)(Ha)(Ha)
这两个正则表达式也匹配同样的模式：
(Ha){3,5}
((Ha)(Ha)(Ha))|((Ha)(Ha)(Ha)(Ha))|((Ha)(Ha)(Ha)(Ha)(Ha))

贪心和非贪心匹配

在字符串'HaHaHaHaHa'中，因为(Ha){3,5}可以匹配3 个、4 个或5 个实例，你可能会想，为什么在前面花括号的例子中，Match 对象的group()调用会
返回'HaHaHaHaHa'，而不是更短的可能结果。毕竟，'HaHaHa'和'HaHaHaHa'也能够有效地匹配正则表达式(Ha){3,5}。
Python 的正则表达式默认是“贪心”的，这表示在有二义的情况下，它们会尽可能匹配最长的字符串。花括号的“非贪心”版本匹配尽可能最短的字符串，即在
结束的花括号后跟着一个问号。
注意在查找相同字符串时，花括号的贪心形式和非贪心形式之间的区别：
>>> greedyHaRegex = re.compile(r'(Ha){3,5}')
>>> mo1 = greedyHaRegex.search('HaHaHaHaHa')
>>> mo1.group()
'HaHaHaHaHa'
>>> nongreedyHaRegex = re.compile(r'(Ha){3,5}?')
>>> mo2 = nongreedyHaRegex.search('HaHaHaHaHa')
>>> mo2.group()
'HaHaHa'
请注意，问号在正则表达式中可能有两种含义：声明非贪心匹配或表示可选的分组。这两种含义是完全无关的。

findall()方法

除了search 方法外，Regex 对象也有一个findall()方法。search()将返回一个Match对象，包含被查找字符串中的“第一次”匹配的文本，而findall()方法
将返回一组字符串，包含被查找字符串中的所有匹配。
>>> phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
>>> mo = phoneNumRegex.search('Cell: 415-555-9999 Work: 212-555-0000')
>>> mo.group()
'415-555-9999'
另一方面，findall()不是返回一个Match 对象，而是返回一个字符串列表，只要在正则表达式中没有分组。列表中的每个字符串都是一段被查找的文本，它匹配该
正则表达式。
>>> phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') # has no groups
>>> phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')
['415-555-9999', '212-555-0000']
如果在正则表达式中有分组，那么findall 将返回元组的列表。每个元组表示一个找到的匹配，其中的项就是正则表达式中每个分组的匹配字符串。
>>> phoneNumRegex = re.compile(r'(\d\d\d)-(\d\d\d)-(\d\d\d\d)') # has groups
>>> phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')
[('415', '555', '1122'), ('212', '555', '0000')]
作为findall()方法的返回结果的总结，请记住下面两点：
1．如果调用在一个没有分组的正则表达式上，例如\d\d\d-\d\d\d-\d\d\d\d，方法findall()将返回一个匹配字符串的列表，
例如['415-555-9999', '212-555-0000']。
2．如果调用在一个有分组的正则表达式上，例如(\d\d\d)-(\d\d\d)-(\d\d\d\d)，方法findall()将返回一个字符串的元组的列表
（每个分组对应一个字符串），例如[('415','555', '1122'), ('212', '555', '0000')]。

字符分类

\d       0 到9 的任何数字
\D       除0 到9 的数字以外的任何字符
\w      任何字母、数字或下划线字符（可以认为是匹配“单词”字符）
\W      除字母、数字和下划线以外的任何字符
\s      空格、制表符或换行符（可以认为是匹配“空白”字符）
\S      除空格、制表符和换行符以外的任何字符
字符分类对于缩短正则表达式很有用。字符分类[0-5]只匹配数字0 到5，这比输入(0|1|2|3|4|5)要短很多。
>>> xmasRegex = re.compile(r'\d+\s\w+')
>>> xmasRegex.findall('12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7
swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge')
['12 drummers', '11 pipers', '10 lords', '9 ladies', '8 maids', '7 swans', '6
geese', '5 rings', '4 birds', '3 hens', '2 doves', '1 partridge']
正则表达式\d+\s\w+匹配的文本有一个或多个数字(\d+)，接下来是一个空白字符(\s)，接下来是一个或多个字母/数字/下划线字符(\w+)。
findall()方法将返回所有匹配该正则表达式的字符串，放在一个列表中。

建立自己的字符分类

有时候你想匹配一组字符，但缩写的字符分类（\d、\w、\s 等）太宽泛。你可以用方括号定义自己的字符分类。例如，字符分类[aeiouAEIOU]将匹配所有元音字
符，不论大小写。
>>> vowelRegex = re.compile(r'[aeiouAEIOU]')
>>> vowelRegex.findall('RoboCop eats baby food. BABY FOOD.')
['o', 'o', 'o', 'e', 'a', 'a', 'o', 'o', 'A', 'O', 'O']
也可以使用短横表示字母或数字的范围。例如，字符分类[a-zA-Z0-9]将匹配所有小写字母、大写字母和数字。
请注意，在方括号内，普通的正则表达式符号不会被解释。这意味着，你不需要前面加上倒斜杠转义.、*、?或()字符。例如，字符分类将匹配数字0 到5 和一个
句点。你不需要将它写成[0-5\.]。
通过在字符分类的左方括号后加上一个插入字符（^），就可以得到“非字符类”。非字符类将匹配不在这个字符类中的所有字符：
>>> consonantRegex = re.compile(r'[^aeiouAEIOU]')
>>> consonantRegex.findall('RoboCop eats baby food. BABY FOOD.')
['R', 'b', 'c', 'p', ' ', 't', 's', ' ', 'b', 'b', 'y', ' ', 'f', 'd', '.', '
', 'B', 'B', 'Y', ' ', 'F', 'D', '.']

插入字符和美元字符

可以在正则表达式的开始处使用插入符号（^），表明匹配必须发生在被查找文本开始处。类似地，可以再正则表达式的末尾加上美元符号（$），表示该字符串必
须以这个正则表达式的模式结束。可以同时使用^和$，表明整个字符串必须匹配该模式，也就是说，只匹配该字符串的某个子集是不够的。
>>> beginsWithHello = re.compile(r'^Hello')
>>> beginsWithHello.search('Hello world!')
<_sre.SRE_Match object; span=(0, 5), match='Hello'>
>>> beginsWithHello.search('He said hello.') == None
True
正则表达式r'\d$'匹配以数字0 到9 结束的字符串：
>>> endsWithNumber = re.compile(r'\d$')
>>> endsWithNumber.search('Your number is 42')
<_sre.SRE_Match object; span=(16, 17), match='2'>
>>> endsWithNumber.search('Your number is forty two.') == None
True
正则表达式r'^\d+$'匹配从开始到结束都是数字的字符串：
>>> wholeStringIsNum = re.compile(r'^\d+$')
>>> wholeStringIsNum.search('1234567890')
<_sre.SRE_Match object; span=(0, 10), match='1234567890'>
>>> wholeStringIsNum.search('12345xyz67890') == None
True
>>> wholeStringIsNum.search('12 34567890') == None
True

通配字符

在正则表达式中，.（句点）字符称为“通配符”。它匹配除了换行之外的所有字符
>>> atRegex = re.compile(r'.at')
>>> atRegex.findall('The cat in the hat sat on the flat mat.')
['cat', 'hat', 'sat', 'lat', 'mat']
要记住，句点字符只匹配一个字符，这就是为什么在前面的例子中，对于文本flat，只匹配lat。要匹配真正的句点，就是用倒斜杠转义：\.

用点-星匹配所有字符

有时候想要匹配所有字符串。例如，假定想要匹配字符串'First Name:'，接下来是任意文本，接下来是'Last Name:'，然后又是任意文本。可以用点-星（.*）
表示“任意文本”。回忆一下，句点字符表示“除换行外所有单个字符”，星号字符表示“前面字符出现零次或多次”。
>>> nameRegex = re.compile(r'First Name: (.*) Last Name: (.*)')
>>> mo = nameRegex.search('First Name: Al Last Name: Sweigart')
>>> mo.group(1)
'Al'
>>> mo.group(2)
'Sweigart'
点-星使用“贪心”模式：它总是匹配尽可能多的文本。要用“非贪心”模式匹配所有文本，就使用点-星和问号。像和大括号一起使用时那样，问号告诉Python 用非贪
心模式匹配。在交互式环境中输入以下代码，看看贪心模式和非贪心模式的区别：
>>> nongreedyRegex = re.compile(r'<.*?>')
>>> mo = nongreedyRegex.search('<To serve man> for dinner.>')
>>> mo.group()
'<To serve man>'
>>> greedyRegex = re.compile(r'<.*>')
>>> mo = greedyRegex.search('<To serve man> for dinner.>')
>>> mo.group()
'<To serve man> for dinner.>'
两个正则表达式都可以翻译成“匹配一个左尖括号，接下来是任意字符，接下来是一个右尖括号”。但是字符串'<To serve man> for dinner.>'对右肩括号有两种
可能的匹配。在非贪心的正则表达式中，Python 匹配最短可能的字符串：'<To serve man>'。在贪心版本中，Python 匹配最长可能的字符串：
'<To serve man> for dinner.>'。

用句点字符匹配换行

点-星将匹配除换行外的所有字符。通过传入re.DOTALL 作为re.compile()的第二个参数，可以让句点字符匹配所有字符，包括换行字符。
>>> noNewlineRegex = re.compile('.*')
>>> noNewlineRegex.search('Serve the public trust.\nProtect the innocent.
\nUphold the law.').group()
'Serve the public trust.'
>>> newlineRegex = re.compile('.*', re.DOTALL)
>>> newlineRegex.search('Serve the public trust.\nProtect the innocent.
\nUphold the law.').group()
'Serve the public trust.\nProtect the innocent.\nUphold the law.'





