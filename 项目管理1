项目7：生成随机的测验试卷文件
假如你是一位地理老师，班上有35 名学生，你希望进行美国各州首府的一个小测验。不妙的是，班里有几个坏蛋，你无法确信学生不会作弊。你希望随机调整
问题的次序，这样每份试卷都是独一无二的，这让任何人都不能从其他人那里抄袭答案。当然，手工完成这件事又费时又无聊。好在，你懂一些Python。
下面是程序所做的事：
• 创建35 份不同的测验试卷。
• 为每份试卷创建50 个多重选择题，次序随机。
• 为每个问题提供一个正确答案和3 个随机的错误答案，次序随机。
• 将测验试卷写到35 个文本文件中。
• 将答案写到35 个文本文件中。
这意味着代码需要做下面的事：
• 将州和它们的首府保存在一个字典中。
• 针对测验文本文件和答案文本文件，调用open()、write()和close()。
• 利用random.shuffle()随机调整问题和多重选项的次序。
第1 步：将测验数据保存在一个字典中
第一步是创建一个脚本框架，并填入测验数据。创建一个名为randomQuizGenerator.py 的文件，让它看起来像这样：
#! python3
# randomQuizGenerator.py - Creates quizzes with questions and answers in
# random order, along with the answer key.
 import random
# The quiz data. Keys are states and values are their capitals.
 capitals = {'Alabama': 'Montgomery', 'Alaska': 'Juneau', 'Arizona': 'Phoenix',
'Arkansas': 'Little Rock', 'California': 'Sacramento', 'Colorado': 'Denver',
'Connecticut': 'Hartford', 'Delaware': 'Dover', 'Florida': 'Tallahassee',
'Georgia': 'Atlanta', 'Hawaii': 'Honolulu', 'Idaho': 'Boise', 'Illinois':
'Springfield', 'Indiana': 'Indianapolis', 'Iowa': 'Des Moines', 'Kansas':
'Topeka', 'Kentucky': 'Frankfort', 'Louisiana': 'Baton Rouge', 'Maine':
'Augusta', 'Maryland': 'Annapolis', 'Massachusetts': 'Boston', 'Michigan':
'Lansing', 'Minnesota': 'Saint Paul', 'Mississippi': 'Jackson', 'Missouri':
'Jefferson City', 'Montana': 'Helena', 'Nebraska': 'Lincoln', 'Nevada':
'Carson City', 'New Hampshire': 'Concord', 'New Jersey': 'Trenton', 'New
Mexico': 'Santa Fe', 'New York': 'Albany', 'North Carolina': 'Raleigh',
'North Dakota': 'Bismarck', 'Ohio': 'Columbus', 'Oklahoma': 'Oklahoma City',
'Oregon': 'Salem', 'Pennsylvania': 'Harrisburg', 'Rhode Island': 'Providence',
'South Carolina': 'Columbia', 'South Dakota': 'Pierre', 'Tennessee':
'Nashville', 'Texas': 'Austin', 'Utah': 'Salt Lake City', 'Vermont':
'Montpelier', 'Virginia': 'Richmond', 'Washington': 'Olympia', 'West
Virginia': 'Charleston', 'Wisconsin': 'Madison', 'Wyoming': 'Cheyenne'}
# Generate 35 quiz files.
 for quizNum in range(35):
# TODO: Create the quiz and answer key files.
# TODO: Write out the header for the quiz.
# TODO: Shuffle the order of the states.
# TODO: Loop through all 50 states, making a question for each.
因为这个程序将随机安排问题和答案的次序，所以需要导入random 模块，以便利用其中的函数。capitals 变量含一个字典，以美国州名作为键，以州首府作
为值。因为你希望创建35 份测验试卷，所以实际生成测验试卷和答案文件的代码（暂时用TODO 注释标注）会放在一个for 循环中，循环35 次（这个数字可以改
变，生成任何数目的测验试卷文件）
第2 步：创建测验文件，并打乱问题的次序
现在是时候填入那些TODO 了。
循环中的代码将重复执行35 次（每次生成一份测验试卷），所以在循环中，你只需要考虑一份测验试卷。首先你要创建一个实际的测验试卷文件，它需要有唯一
的文件名，并且有某种标准的标题部分，留出位置，让学生填写姓名、日期和班级。然后需要得到随机排列的州的列表，稍后将用它来创建测验试卷的问题和答案。
在randomQuizGenerator.py 中添加以下代码行：
#! python3
# randomQuizGenerator.py - Creates quizzes with questions and answers in
# random order, along with the answer key.
--snip--
# Generate 35 quiz files.
for quizNum in range(35):
# Create the quiz and answer key files.
 quizFile = open('capitalsquiz%s.txt' % (quizNum + 1), 'w')
 answerKeyFile = open('capitalsquiz_answers%s.txt' % (quizNum + 1), 'w')
# Write out the header for the quiz.
 quizFile.write('Name:\n\nDate:\n\nPeriod:\n\n')
quizFile.write((' ' * 20) + 'State Capitals Quiz (Form %s)' % (quizNum + 1))
quizFile.write('\n\n')
# Shuffle the order of the states.
states = list(capitals.keys())
 random.shuffle(states)
# TODO: Loop through all 50 states, making a question for each.
测验试卷的文件名将是capitalsquiz<N>.txt，其中<N>是该测验试卷的唯一编号，来自于quizNum，即for 循环的计数器。针对capitalsquiz<N>.txt 的答案将
保存在一个文本文件中，名为capitalsquiz_answers<N>.txt。每次执行循环，'capitalsquiz%s.txt'和'capitalsquiz_answers%s.txt'中的占位符%s 都将
被(quizNum + 1)取代，所以第一个测验试卷和答案将是capitalsquiz1.txt 和capitalsquiz_answers1.txt。在和的open()函数调用将创建这些文件，
以'w'作为第二个参数，以写模式打开它们。处write()语句创建了测验标题，让学生填写。最后，利用random.shuffle()函数，创建了美国州名的随机列表。
该函数重新随机排列传递给它的列表中的值。
第3 步：创建答案选项
现在需要为每个问题生成答案选项，这将是A 到D 的多重选择。你需要创建另一个for 循环，该循环生成测验试卷的50 个问题的内容。然后里面会嵌套第三个
for 循环，为每个问题生成多重选项。让你的代码看起来像这样：
#! python3
# randomQuizGenerator.py - Creates quizzes with questions and answers in
# random order, along with the answer key.
--snip--
# Loop through all 50 states, making a question for each.
for questionNum in range(50):
# Get right and wrong answers.
 correctAnswer = capitals[states[questionNum]]
 wrongAnswers = list(capitals.values())
 del wrongAnswers[wrongAnswers.index(correctAnswer)]
 wrongAnswers = random.sample(wrongAnswers, 3)
 answerOptions = wrongAnswers + [correctAnswer]
 random.shuffle(answerOptions)
# TODO: Write the question and answer options to the quiz file.
# TODO: Write the answer key to a file.
正确的答案很容易得到，它作为一个值保存在capitals 字典中。这个循环将遍历打乱过的states 列表中的州，从states[0]到states[49]，在capitals 中找到
每个州，将该州对应的首府保存在correctAnswer 中。可能的错误答案列表需要一点技巧。你可以从capitals 字典中复制所有的值，删除正确的答案，然后从该
列表中选择3 个随机的值。random.sample()函数使得这种选择很容易，它的第一个参数是你希望选择的列表，第二个参数是你希望选
择的值的个数。完整的答案选项列表是这3 个错误答案与正确答案的组合。最后，答案需要随机排列，这样正确的答案就不会总是选项D。
第4 步：将内容写入测验试卷和答案文件
剩下来就是将问题写入测验试卷文件，将答案写入答案文件。让你的代码看起来像这样：
#!python3
# randomQuizGenerator.py - Creates quizzes with questions and answers in
# random order, along with the answer key.
--snip--
# Loop through all 50 states, making a question for each.
for questionNum in range(50):
--snip--
# Write the question and the answer options to the quiz file.
quizFile.write('%s. What is the capital of %s?\n' % (questionNum + 1,
states[questionNum]))
 for i in range(4):
 quizFile.write(' %s. %s\n' % ('ABCD'[i], answerOptions[i]))
quizFile.write('\n')
# Write the answer key to a file.
 answerKeyFile.write('%s. %s\n' % (questionNum + 1, 'ABCD'[
answerOptions.index(correctAnswer)]))
quizFile.close()
answerKeyFile.close()
一个遍历整数0 到3的for 循环，将答案选项写入answerOptions 列表。处的表达式'ABCD'[i]将字符串'ABCD'看成是一个数组，它在循环的每次迭代中，将分
别求值为'A'、'B'、'C'和'D'。在最后一行，表达式answerOptions.index(correctAnswer)将在随机排序的答案选项中，找到正确答案的整数下标，并且
'ABCD'[answerOptions.index(correctAnswer)]将求值为正确答案的字母，写入到答案文件中。
在运行该程序后，下面就是capitalsquiz1.txt 文件看起来的样子。但是，你的问题和答案选项当然与这里显示的可能会不同。这取决于random.shuffle()
调用的结果：
Name:
Date:
Period:
  State Capitals Quiz (Form 1)
1. What is the capital of West Virginia?
  A. Hartford
  B. Santa Fe
  C. Harrisburg
  D. Charleston
2. What is the capital of Colorado?
  A. Raleigh
  B. Harrisburg
  C. Denver
  D. Lincoln
--snip--
对应的capitalsquiz_answers1.txt 文本文件看起来像这样：
1. D
2. C
3. A
4. C
--snip--

项目8：多重剪贴板
假定你有一个无聊的任务，要填充一个网页或软件中的许多表格，其中包含一些文本字段。剪贴板让你不必一次又一次输入同样的文本，但剪贴板上一次只有一
个内容。如果你有几段不同的文本需要拷贝粘贴，就不得不一次又一次的标记和拷贝几个同样的内容。可以编写一个Python 程序，追踪几段文本。这个“多重剪贴板”
将被命名为mcb.pyw（因为“mcb”比输入“multiclipboard”更简单）。.pyw 扩展名意味着Python运行该程序时，不会显示终端窗口。该程序将利用一个关键字保存
每段剪贴板文本。例如，当运行py mcb.pyw save spam，剪贴板中当前的内容就用关键字spam 保存。通过运行py mcb.pyw spam，这段文本稍后将重新加载到
剪贴板中。如果用户忘记了都有哪些关键字，他们可以运行py mcb.pyw list，将所有关键字的列表复制到剪贴板中。
下面是程序要做的事：
• 针对要检查的关键字，提供命令行参数。
• 如果参数是save，那么将剪贴板的内容保存到关键字。
• 如果参数是list，就将所有的关键字拷贝到剪贴板。
• 否则，就将关键词对应的文本拷贝到剪贴板。
这意味着代码需要做下列事情：
• 从sys.argv 读取命令行参数。
• 读写剪贴板。
• 保存并加载shelf 文件。
如果你使用Windows，可以创建一个名为mcb.bat 的批处理文件，很容易地通过“Run…”窗口运行这个脚本。该批处理文件包含如下内容：
@pyw.exe C:\Python34\mcb.pyw %*
第1 步：注释和shelf 设置
我们从一个脚本框架开始，其中包含一些注释和基本设置。让你的代码看起来像这样：
#! python3
# mcb.pyw - Saves and loads pieces of text to the clipboard.
 # Usage: py.exe mcb.pyw save <keyword> - Saves clipboard to keyword.
# py.exe mcb.pyw <keyword> - Loads keyword to clipboard.
# py.exe mcb.pyw list - Loads all keywords to clipboard.
 import shelve, pyperclip, sys
 mcbShelf = shelve.open('mcb')
# TODO: Save clipboard content.
# TODO: List keywords and load content.
m cbShelf.close()
将一般用法信息放在文件顶部的注释中，这是常见的做法。如果忘了如何运行这个脚本，就可以看看这些注释，帮助回忆起来。然后导入模块。拷贝和粘贴
需要pyperclip 模块，读取命令行参数需要sys 模块。shelve 模块也需要准备好。当用户希望保存一段剪贴板文本时，你需要将它保存到一个shelf 文件中。
然后，当用户希望将文本拷贝回剪贴板时，你需要打开shelf 文件，将它重新加载到程序中。这个shlef 文件命名时带有前缀mcb。
第2 步：用一个关键字保存剪贴板内容
根据用户希望保存文本到一个关键字，或加载文本到剪贴板，或列出已有的关键字，该程序做的事情不一样。让我们来处理第一种情况。让你的代码看起来像这样：
#! python3
# mcb.pyw - Saves and loads pieces of text to the clipboard.
--snip--
# Save clipboard content.
 if len(sys.argv) == 3 and sys.argv[1].lower() == 'save':
 mcbShelf[sys.argv[2]] = pyperclip.paste()
elif len(sys.argv) == 2:
 # TODO: List keywords and load content.
m cbShelf.close()
如果第一个命令行参数（它总是在sys.argv 列表的下标1 处）是字符串'save' ，第二个命令行参数就是保存剪贴板当前内容的关键字。关键字将用做 mcbShelf 
中的键，值就是当前剪贴板上的文本。如果只有一个命令行参数，就假定它要么是'list'，要么是需要加载到剪贴板的关键字。稍后你将实现这些代码。现在只是
放上一条TODO 注释。
第3 步：列出关键字和加载关键字的内容
最后，让我们实现剩下的两种情况。用户希望从关键字加载剪贴板文本，或希望列出所有可用的关键字。让你的代码看起来像这样：
#! python3
# mcb.pyw - Saves and loads pieces of text to the clipboard.
--snip--
# Save clipboard content.
if len(sys.argv) == 3 and sys.argv[1].lower() == 'save':
mcbShelf[sys.argv[2]] = pyperclip.paste()
elif len(sys.argv) == 2:
# List keywords and load content.
 if sys.argv[1].lower() == 'list':
 pyperclip.copy(str(list(mcbShelf.keys())))
elif sys.argv[1] in mcbShelf:
 pyperclip.copy(mcbShelf[sys.argv[1]])
m cbShelf.close()
如果只有一个命令行参数，首先检查它是不是'list' 。如果是，表示shelf 键的列表的字符串将被拷贝到剪贴板。用户可以将这个列表拷贝到一个打开的文本编
辑器，进行查看。否则，你可以假定该命令行参数是一个关键字。如果这个关键字是shelf 中的一个键，就可以将对应的值加载到剪贴板。齐活了！加载这个程序
有几个不同步骤，这取决于你的计算机使用哪种操作系统。回忆一下前面创建的口令保管箱程序，它将口令保存在一个字典中。更新口令需要更改该程序的源代码。
这不太理想，因为普通用户不太适应通过更改源代码来更新他们的软件。而且，每次修改程序的源代码时，就有可能不小心引入新的缺陷。将程序的数据保存在不同
的地方，而不是在代码中，就可以让别人更容易使用你的程序，并且更不容易出错。

项目9：将一个文件夹备份到一个ZIP 文件
假定你正在做一个项目，它的文件保存在C:\AlsPythonBook 文件夹中。你担心工作会丢失，所以希望为整个文件夹创建一个ZIP 文件，作为“快照”。你希望保存
不同的版本，希望ZIP 文件的文件名每次创建时都有所变化。例如AlsPythonBook_1.zip、AlsPythonBook_2.zip、AlsPythonBook_3.zip，等等。你可以手工完成，
但这有点烦人，而且可能不小心弄错ZIP 文件的编号。运行一个程序来完成这个烦人的任务会简单得多。针对这个项目，打开一个新的文件编辑器窗口：
第1 步：弄清楚ZIP 文件的名称
这个程序的代码将放在一个名为backupToZip()的函数中。这样就更容易将该函数复制粘贴到其他需要这个功能的Python 程序中。在这个程序的末尾，会调用这个
函数进行备份。让你的程序看起来像这样：
#! python3
# backupToZip.py - Copies an entire folder and its contents into
# a ZIP file whose filename increments.
 import zipfile, os
def backupToZip(folder):
# Backup the entire contents of "folder" into a ZIP file.
folder = os.path.abspath(folder) # make sure folder is absolute
# Figure out the filename this code should use based on
# what files already exist.
 number = 1
 while True:
zipFilename = os.path.basename(folder) + '_' + str(number) + '.zip'
if not os.path.exists(zipFilename):
break
number = number + 1
 # TODO: Create the ZIP file.
# TODO: Walk the entire folder tree and compress the files in each folder.
print('Done.')
b ackupToZip('C:\\delicious')
先完成基本任务：添加#!行，描述该程序做什么，并导入zipfile 和os 模块。定义backupToZip()函数，它只接收一个参数，即folder。这个参数是一个字符
串路径，指向需要备份的文件夹。该函数将决定它创建的ZIP 文件使用什么文件名，然后创建该文件，遍历folder 文件夹，将每个子文件夹和文件添加到ZIP 文件中。
在源代码中为这些步骤写下TODO 注释，提醒你稍后来完成。第一部分命名这个ZIP 文件，使用folder 的绝对路径的基本名称。如果要备份的文件夹是
C:\delicious，ZIP 文件的名称就应该是delicious_N.zip，第一次运行该程序时N=1，第二次运行时N=2，以此类推。通过检查delicious_1.zip 是否存在，
然后检查delicious_2.zip 是否存在，继续下去，可以确定N 应该是什么。用一个名为number 的变量表示N，在一个循环内不断增加它，并调用
os.path.exists()来检查该文件是否存在。第一个不存在的文件名将导致循环break，因此它就发现了新ZIP 文件的文件名。
第2 步：创建新ZIP 文件
接下来让我们创建ZIP 文件。让你的程序看起来像这样：
#! python3
# backupToZip.py - Copies an entire folder and its contents into
# a ZIP file whose filename increments.
--snip--
while True:
zipFilename = os.path.basename(folder) + '_' + str(number) + '.zip'
if not os.path.exists(zipFilename):
break
number = number + 1
# Create the ZIP file.
print('Creating %s...' % (zipFilename))
 backupZip = zipfile.ZipFile(zipFilename, 'w')
# TODO: Walk the entire folder tree and compress the files in each folder.
print('Done.')
b ackupToZip('C:\\delicious')
既然新ZIP 文件的文件名保存在zipFilename 变量中，你就可以调用zipfile.ZipFile()，实际创建这个ZIP 文件。确保传入'w'作为第二个参数，这样ZIP
文件以写模式打开。
第3 步：遍历目录树并添加到ZIP 文件
现在需要使用os.walk()函数，列出文件夹以及子文件夹中的每个文件。让你的程序看起来像这样：
#! python3
# backupToZip.py - Copies an entire folder and its contents into
# a ZIP file whose filename increments.
--snip--
# Walk the entire folder tree and compress the files in each folder.
 for foldername, subfolders, filenames in os.walk(folder):
print('Adding files in %s...' % (foldername))
# Add the current folder to the ZIP file.
 backupZip.write(foldername)
# Add all the files in this folder to the ZIP file.
 for filename in filenames:
newBase / os.path.basename(folder) + '_'
if filename.startswith(newBase) and filename.endswith('.zip')
continue # don't backup the backup ZIP files
backupZip.write(os.path.join(foldername, filename))
backupZip.close()
print('Done.')
b ackupToZip('C:\\delicious')
可以在for 循环中使用os.walk()，在每次迭代中，它将返回这次迭代当前的文件夹名称、这个文件夹中的子文件夹，以及这个文件夹中的文件名。
在这个for 循环中，该文件夹被添加到ZIP 文件。嵌套的for 循环将遍历filenames 列表中的每个文件。每个文件都被添加到ZIP 文件中，以前生成的备份
ZIP 文件除外。如果运行该程序，它产生的输出看起来像这样：
Creating delicious_1.zip...
Adding files in C:\delicious...
Adding files in C:\delicious\cats...
Adding files in C:\delicious\waffles...
Adding files in C:\delicious\walnut...
Adding files in C:\delicious\walnut\waffles...
Done.
第二次运行它时，它将C:\delicious 中的所有文件放进一个ZIP 文件，命名为delicious_2.zip，以此类推。
第4 步：类似程序的想法
你可以在其他程序中遍历一个目录树，将文件添加到压缩的ZIP 归档文件中。例如，你可以编程做下面的事情：
• 遍历一个目录树，将特定扩展名的文件归档，诸如.txt 或.py，并排除其他文件。
• 遍历一个目录树，将除.txt 和.py 文件以外的其他文件归档。
• 在一个目录树中查找文件夹，它包含的文件数最多，或者使用的磁盘空间最大。

